# -*- coding: utf-8 -*-
"""高演期末code.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10qPFFmGPpA_zu-pAsV4DpaYQRjAf0b7s
"""

with open('RPD2.rtf', 'r') as file:
    text = file.read()

#整理text資料
text = text.split("\\\n")[3:]
text[100] = 'Job 99: 57, 91, 20, 476'
text[:10]

data = []
for i in range(1,101):
    temp = text[i].split(":")[1].split(",")
    temp = [int(item) for item in temp]
    job_num = int(text[i].split(":")[0].split("Job")[1])
    temp.insert(0, job_num)
    data.append(temp)

data[:5] #列前五筆 [job_j, alpha_j, beta_j, p_j, d_j]

#machine1 list 裝偶數job
machine1 = data[0::2]
#machine2 list 裝奇數job
machine2 = data[1::2]

#machine list index 0 的位置 設 0 方便list之後使用
machine1.insert(0,0)
machine2.insert(0,0)

#列出前五筆
print(machine1[:5])
print(machine2[:5])

def delta_summation(machine_list, job_from, job_to): # δfunction = summation:beta_j - alpha_j
    result = 0
    for i in range(job_from, job_to+1):
        if i != 0:
            result += (machine_list[i][2] - machine_list[i][1])
    return(result)

def tardness(completion_time, due_date):
  return max(0, completion_time - due_date)

def BDP2(i, j, l):

  def L_f(i, j, i_p, j_p):
    p1 = sum(row[3] for row in machine_1[i:i_p+1])
    p2 = sum(row[3] for row in machine_2[j:j_p+1])
    sum_f1 = 0
    sum_f2 = 0
    for h in range(i, i_p+1):
      sum_f1 += tardness(l + sum(row[3] for row in machine_1[i:h+1]), machine_1[h][4])
    for h in range(j, j_p+1):
      sum_f2 += tardness(l + sum(row[3] for row in machine_2[j:h+1]), machine_2[h][4])
    
    return BDP2(i_p+1, j_p+1, l+max(p1, p2)) + sum_f1 + sum_f2

  def H(i, j):
    i_p = i
    j_p = j
    H = set()
    def c_A():
      return v_0 + delta_summation(machine_1, 0, i_p-1) + delta_summation(machine_2, 0, j_p-1) - machine_1[i_p][1] - machine_2[j_p][1] >= 0
    while i_p <= n1 and j_p <= n2 and sum(row[3] for row in machine_1[i:i_p+1])!=sum(row[3] for row in machine_2[j:j_p+1]) and c_A():
      H.add((i , j , i_p, j_p))
      if sum(row[3] for row in machine_1[i:i_p+1]) < sum(row[3] for row in machine_2[j:j_p+1]):
        i_p = i_p+1
      else:
        j_p = j_p+1
    return H
  

  if (i == n1+1 and j == n2+1):
    return 0

  if (i <= n1 and j == n2+1): 
    if (v_0 + delta_summation(machine_1, 0, i-1) + delta_summation(machine_2, 0, j-1) - machine_1[i][1] >= 0):
        td = tardness(l + machine_1[i][3], machine_1[i][4])
        z1 = BDP2(i+1, j, l + machine_1[i][3]) + td
    else:
        z1 = float('inf')
    return z1

  if (i == n1+1 and j <= n2): 
    if (v_0 + delta_summation(machine_1, 0, i-1) + delta_summation(machine_2, 0, j-1) - machine_2[j][1] >= 0):
        td = tardness(l + machine_2[j][3], machine_2[j][4])
        z2 = BDP2(i, j+1, l + machine_2[j][3]) + td
    else:
        z2 = float('inf')
    return z2

  else:
    if (v_0 + delta_summation(machine_1, 0, i-1) + delta_summation(machine_2, 0, j-1) - machine_1[i][1] >= 0):
        td = tardness(l + machine_1[i][3], machine_1[i][4])
        z1 = BDP2(i+1, j, l + machine_1[i][3]) + td
    else:
        z1 = float('inf')

    if (v_0 + delta_summation(machine_1, 0, i-1) + delta_summation(machine_2, 0, j-1) - machine_2[j][1] >= 0):
        td = tardness(l + machine_2[j][3], machine_2[j][4])
        z2 = BDP2(i, j+1, l + machine_2[j][3]) + td
    else:
        z2 = float('inf')

    h = H(i, j)
    if len(h) != 0:
        L_list = []
        for x,y,x_prime,y_prime in h:
            l = L_f(x,y,x_prime,y_prime)
            L_list.append(l)
            z3 = min(L_list)

    else:
        z3 = float('inf')
    
    return min(z1, z2, z3)

v_0 = 70
n1 = n2 = 10
machine_1 = machine1[:n1+1]
machine_2 = machine2[:n2+1]

BDP2(1, 1, 0)

# n1 = n2 = 20
# 手算答案：：(1, 1) = 8, (1, 2) = 21, (2, 1) = 24, (2, 2) = 37, (2, 3) = 51